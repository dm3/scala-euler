class InfiniteIterable[S, E](init: S, calcNext: Array[S] => E) extends Iterable.Projection[E] {
    override val hasDefiniteSize, isEmpty = false

    def elements = new Iterator[E] {
        val state: Array[S] = new Array[S](1);
        state(0) = init
        val hasNext = true

        def next = calcNext(state)
    }
}

case class Node[T <% Ordered[T]](value: T, left: Node[T], right: Node[T]) {
    def foldLeft[A](init: A)(f: (A, T) => A): A = f(right.foldLeft(left.foldLeft(init)(f))(f), value)
    def ^ = left max right
}

case class Empty[T <% Ordered[T]] extends Node[T](null.asInstanceOf[T], null.asInstanceOf[Node[T]], null.asInstanceOf[Node[T]]) {
    override def foldLeft[A](init: A)(f: (A, T) => A): A = init
}

case class Root[T <% Ordered[T]](override val left: Node[T], override val right: Node[T]) extends Node[T](null.asInstanceOf[T], left, right) {
    override def foldLeft[A](init: A)(f: (A, T) => A): A = right.foldLeft(left.foldLeft(init)(f))(f)
}

object Util {
    import BigInt._
    import scala.io.Source._

    def readLinesAsNumbers(file: String): Iterator[Array[Int]] =
        fromFile(file).getLines.map(_.split(" ").map(_.stripLineEnd).map(_.toInt))

    def fact(n: BigInt) = {
        def fact1(n: BigInt, acc: BigInt): BigInt = if (n == 0) acc else fact1(n - 1, acc * n)
        fact1(n, 1)
    }

    // 1, 2, 3, 4, ...
    def ints(n: Int): Stream[Int] = Stream.cons(n, ints(n + 1))

    // 2, 3, 5, 7, 11, ...
    def primes(nums: Stream[Int]): Stream[Int] = Stream.cons(nums head,
        primes((nums tail) filter (_ % nums.head != 0)))

    /**
     * The sequence of triangle numbers is generated by adding the natural numbers.
     * So the 7^(th) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
     */
    def triangles(nums: Stream[Int]): Stream[Int] = Stream.cons(nums head,
        triangles(Stream.cons(nums.head + nums.tail.head, nums.tail drop 1)))
}